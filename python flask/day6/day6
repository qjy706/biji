１．关系映射
    1.一对多　
        语法：　
            １．在多的实体中
                增加一个列，引用自'一'的主键列　
                外键列名　= db.Column(db.Integer,db.ForeignKey('主表.主键'))
                                    主表主键什么类型　里面就什么类型


            2.  在　'一'的实体中
                增加关联属性以及反向引用关系
                ex:
                    关联属性：
                        在course对象中，通过一个属性能够得到对应的所有的Teacher们　
                        一的实体中　通过一个属性能得到对应的　多的实体中　


                    反向引用　：
                        在Teacher对象中，通过一个属性能够得到对应的course

                        在一的里面做　 反向反向　　就是在一的里面操作多　
                        个人理解　多的实体中　通过一个属性能得到对应的　一的实体中　

                增加关联属性　和　反向引用关系　
                属性名　＝　db.relationship('多表的实体类名',关系选项='') 关系选项可以写两个
                关系选项:

                选项名                         说明
                backref                     在关系的另一个模型(多)中添加的反向引用名
                                         (准备在'多'的实体中增加对一的实体引用的属性名)

                lazy                         指定如何加载当前的相关记录
                                         select: 首次访问时加载记录　
                                         immediate : 源对象加载后马上加载相关数据(用一次加载一次)
                                         subquery : 效果同上，利用子查询方式加载记录　
                                         noload : 永不加载记录　
                                         dynamic : 默认不加载记录，但会提供加载记录的查询　

                uselist                 如果设置为False,表示不使用列表表示关联数据，而使用标量　

                secondary               指定多对多关系映射中的关联表的名字


    2.  一对一
        １．什么是一对一
            A表中的一条记录只能与B表中的一条记录相关联
            B表中的一条记录只能与A表中的一条记录相关联　

        ２． 在SQLAlchemy中的体现
            １．在任意一张表中增加
                外键列名 = db.Column(db.Integer,db.ForeignKey('主键表.主键列'))

            ２．在另外一个类中增加
                关联属性　和　反向引用关系属性　
                属性=db.relationship('关联的实体类',backref='反向引用属性名',uselist=False)