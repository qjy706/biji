python高级
lvze@tedu.cn



本阶段课程安排　

１　网络编程　（４天）　
２　进程线程　（５天）
３　MongoDB 数据库　（４天）
４　正则表达式　（１天）
５　项目　（2.５）
６　git使用




网络编程

网络功能：　数据传输


ＩＳＯ（国际标准化组织）

ＯＳＩ七层模型　－－》　网络通信工作流程的标准化

应用层：提供用户服务，具体功能有特定程序而定

表示层：数据的压缩优化，加密

会话层：建立应用级的连接，选择传输服务


传输层：提供不同的传输服务（已适应应用层需求）。流量控制  tcp/udp


网络层：路由选择，网络互连　



链路层：进行数据转换，具体消息的发送，链路连接

物理层：物理硬件，接口设定，网卡路由交换机等　（高低电频）　

cookie 
高内聚:　模块功能尽可能单一，不要掺杂
低耦合：模块之间尽可能减少关联和影响


ＯＳＩ七层模型优点：　１，　将工作流程标准化
　　　　　　　　　　　　　　　　　　２，降低模块间的耦合度，是每一部分可以单独开发，单独工作。


四层模型:应用层：　应用层，表示层，会话层
　　　　　　　　传输层
　　　　　　　　网络层
　　　　　　　　物理链路层　



五层模型(TCP/IP)：　应用层：应用层，表示层，会话层
　　　　　　　　　　　　　　　　　传输层
　　　　　　　　　　　　　　　　　网络层
　　　　　　　　　　　　　　　　　链路层
　　　　　　　　　　　　　　　　　物理层
　　　　　　　　　　　　　　　　　　

数据传输流程　　
１，发送端由应用层到物理层逐层添加信息头（首部），最终由物理层发送　
２，中间经过节点（交换机，路由器等）转发，发送到接收端
３，在接收端根据发送端的每个信息头进行解析，最终消息到应用层展示给用户　


协议　

网络协议：在网络通信中双方都遵循的规定，包括建立什么样的网络结构，消息结构，标识代表什么等。

应用层：　TFTP HTTP DNS SMTP 

传输层：　TCP UDP

网络层：　IP 

物理层：　IEEE  


网络相关概念　

网络主机：在网络中标识一台计算机　　HOST　　
# 现在编写应用程序　不想被别人访问　只想本机测试再让其他人连接　

本地使用:  'localhost' 表示本地测试　
　　　　　　　　　 '127.0.0.1'  本机测试ip 


网络使用：　'0.0.0.0'  表示当前计算机可用网卡地址　
　　　　　　　　　　ifconfig    176.8.18.212



获取计算机名　

ipython3 

In [3]: import socket#插座 

In [4]: socket.gethostname()
Out[4]: 'tedu'

In [5]: socket.gethostbyname('tedu')
Out[5]: '127.0.1.1'#给计算机名的一个测试ip


ip地址　
网络上确定一台主机网络位置的地址　



ipv4:点分十进制　　192.168.1.2     0---255   32位　４＊８

ipv6:128位　　


ping ip:测试和某台网络主机是否联通

特殊ip地址：　127.0.0.1 本地测试ip　
　　　　　　　　　　　　0.0.0.0　使用本机可用ip　
　　　　　　　　　　　　192.168.1.0 表示网段ip 
　　　　　　　　　　　192.168.1.1 网关ip 
　　　　　　　　　　　192.168.1.255 广播地址　

通过地址获取主机网络信息　
In [16]: socket.gethostbyaddr('localhost')
Out[16]: ('localhost', [], ['127.0.0.1'])
　　　　　　　　　　　　主机名　　　　　别名　　　　　网络地址



In [1]: socket.gethostbyaddr('www.baidu.com')



点分十进制地址转换为二进制　
In [3]: socket.inet_aton('192.168.1.2')
Out[3]: b'\xc0\xa8\x01\x02'

二进制地址转换为点分十进制
In [6]: socket.inet_ntoa(b'\xc0\xa8\x01\x02')
Out[6]: '192.168.1.2'


域名：网络服务器地址的名称　　百度是一个域名　他有一个地址　


网络端口号　

端口号是网络地址的一部分，用于区分一个网络主机上的网络应用　
　＊　在一个操作系统中不同的网络应用监听不同的端口号　

取值范围　１－65535
　　　　　1-255    一些众所周知的通用端口　
     2-256    系统应用端口　
     1024-65535 自用端口
     mysql 3306 建议使用大于１００００的端口


     获取端口号　

    socket.getservbyname('应用名字')

网络字节序　
　　　　　数据在网络中的传输格式　


传输层服务　
传输层：提供不同的传输服务（已适应应用层需求）。流量控制

面向连接的传输服务　

基于　tcp 协议的数据传输　
传输特征：提供可靠的数据传输，可靠性值数据传输过程中无丢失，无失序，无差错，无重复

实现手段　：数据传输断开前都需要进行传输和断开的确认　

三次握手：tcp传输在数据传输前建立连接的过程　　
１，客户端向服务器发送连接请求
２，服务器收到请求后，回复确认消息，表示允许连接
３，客户端收到服务器回复，进行最终标志发送确认连接　

四次挥手：tcp传输在连接断开前进行断开确认的过程　
１，主动方发送报文告知被动方要断开连接
２，被动方收到请求后立即返回报文告知可以断开　
３，被动方准备就绪后再次发送报文告知可以断开
４，主动方发送消息，确认最终断开

应用情况：适用于传输较大的文件，网络情况较好，需要保证传输可靠性的情况
比如：网页的获取，文件下载，邮件传输，登录注册　


面向无连接的传输服务　

基于udp协议的传输　
传输特点　：不保证传输的可靠性　，传输过程没有连接和断开的流程，数据收发自由。（有基本的流畅性）

应用情况：网络情况较差，对传输可靠性要求不高，需要提升传输效率。不便连接，需要灵活收发信息。
比如：网络视频，群聊，广播发送


要求：
　　　１．osi七层模型介绍一下　，tcp/ip模型
　　　２，tcp和udp服务有什么区别　
　　　３，三次握手和四次挥手什么意思　过程是怎样的



socket　套接字编程

　　目标：　根据socket模块提供的接口函数，进行组合使用完成基于tcp或者udp的网路编程
　　套接字：　完成上述目标的一种编程手段，编程方案　
　　套接字分类：　
　　　　　　　　　　
　　　　　　　　　　流式套接字（SOCK_STREAM）:传输层基于tcp协议的套接字编程方案

　　　　　　　　　　数据报套接字（SOCK_DGRAM）：传输层基于udp协议的套接字变成方案　

　　　　　　　　　　底层套接字（SOCK_RAM）：访问底层协议的套接字编程


tcp套接字服务端编程　
　　　　　　　　　　　
　　　　　　　　　　socket
             | 
           bind
             | 
          listen
             |   <-----
           accept      |
             |         |
        send/recv -> close 


   import socket
1 创建套接字　
sockfd=socket.socket(sock_family = AF_INET,socket_type=SOCK_STREAM,proto=0) 
功能：　创建套接字　
参数：　socket_family : 选择地址族类型　AF_INET 是IPV4的　 
      socket_type:套接字类型　　　SOCK_STREAM　流式套接字
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　SOCK_DGRAM　　数据报

　　　　　　　proto　：　选择子协议类型　０表示不选择任何子协议
　
返回值：　返回套接字对象　
　　　　　　　
２　绑定服务端地址　

sockfd.bind(addr)

功能：绑定ip地址
参数：元组（ip,port）　addr是一个元组　里面包含ip　和端口　1-65535 不过最好往大的取
localhost  可以被本机用　127.0.0.1 访问
127.0.0.1  同上

192.168.x.x 可以被别人用　192.168.x.x访问　
0.0.0.0  可以被别人用　192.168.x.x访问　也可以被自己用127.0.0.1 访问

３　设置监听套接字　（让套接字可以连接　）

sockfd.listen(n)

功能；　讲套接字设置为监听套接字，创建监听队列　
参数：　n表示监听队列大小　

＊　一个监听套接字可以连接多个客户端套接字　


４　等待处理客户端连接请求　
connfd,addr = sockfd.accept() 
功能：阻塞等待处理客户端连接　
返回值：connfd  客户端连接套接字　
　　　　　　　addr    连接的客户端地址　


＊阻塞函数：　程序运行过程中遇到阻塞函数则暂停运行，知道某种阻塞条件达成再继续运行　
            input 
           time.sleep
           accept 
           recv
           join 
           


5 消息收发　
　　connfd.recv(buffersize)
#connfd是连接套接字　跟客户端通信
功能：　接受对应客户端信息　
参数：　一次最多接受多少字节　
返回值：　接收到的内容　

＊如果没有消息则会阻塞　

n=connfd.send(data)
功能：　发送消息给对应客户端　
参数：　要发送的内容，必须是bytes　格式　
返回值：返回实际发送消息的大小（字节）　


６　关闭套接字　
connfd.close()
sockfd.close()

telnet　对方服务器地址　端口　




客户端连接套接字　

socket

connect 

send/recv

close


1，创建套接字　
＊　必须相同类型套接字才能通信

２，建立连接
　sockfd.connect(servr_addr)
功能：　建立连接
参数：　元组　服务器地址　
３，消息收发　
＊消息收发要和服务器配合，避免两边都出现recv阻塞　
４，关闭套接字　




 