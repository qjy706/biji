僵尸进程　

子进程先于父进程退出，但是父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程

*僵尸进程会存留少量pcb信息在内存中，大量的僵尸进程会消耗系统资源，应该避免僵尸进程产生　

如何避免僵尸进程产生
　

＊处理子进程退出状态

pid,status = os.wait()
功能：在父进程中阻塞等待处理子进程退出　
返回值：　pid退出的子进程的pid号　
　　　　　　　　status 获取子进程退出状态　

pid,status = os.waitpid(pid,option)

功能：在父进程中阻塞等待处理子进程退出
　
参数：　pid -1  表示等待任意子进程退出　
          >0  表示等待对应pid号的子进程退出
      option   0   表示阻塞等待　
      　　　　　　　　　WHOHANG  表示非阻塞

返回值：　pid退出的子进程的pid号　
　　　　　　　　status 获取子进程退出状态　

waitpid(-1,0)  等同于　wait

os.WEXITSTATUS(status)  返回的时候自己设置退出的数字

＊让父进程先退出　
   1,父进程创建子进程等待子进程退出
   ２，子进程创建二级子进程后立即退出
   ３，二级子进程称为孤儿，和原来的父进程各自执行事件


孤儿进程：

父进程先于子进程退出，此时子进程就成为孤儿进程

＊孤儿进程会被操作系统指定的进程收养，系统进程就成为孤儿进程的新的父进程



multiprocessing 模块创建进程


１．需要将要执行的事情封装为函数　

２．使用multiprocessing模块中process类创建进程对象　

３．通过对象属性设置和process 的初始化函数对进程进行设置，绑定要执行的函数　

４．启动进程，会自动执行绑定的函数

５．完成进程的回收　

Process()  
功能：　创建进程对象　
参数：name 进程名称　　　process-1 
     target 进程绑定函数　 
     args 元祖　给target 函数按照位置传参　
    　kwargs 字典　给　target 函数按照键值对传参　
    　

p.start()
功能　启动进程　
*target函数会自动执行　，此时进程真正被创建　

p.join([timeout])
功能：　阻塞等待回收p的子进程　
参数：超时时间　



*使用multiprocessing 创建子进程，同样子进程赋值父进程
的全部代码段
父子进程各自执行互不影响，父子进程有各自的运行空间


写五个函数　写五个对象　启动　就等于创建五个子进程　

*使用multiprocessing创建子进程往往父进程只是用
　　来创建进程回收进程
可以视情况使用循环　



梳理巩固聊天室代码思路　
巩固multiprocessing 创建进城的方法
创建一个父子进程，分别将一个文件的上半部分和下半部分复制到
一个新的文件中　，创建进程方法　